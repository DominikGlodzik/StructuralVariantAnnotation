---
title: "StructuralVariantAnnotation Quick Overview"
author: "Ruining Dong"
date: "`r Sys.Date()`"
output:
  pdf_document:
    toc: yes
  html_document:
    toc: yes
    toc_float:
      collapsed: yes
      smooth_scroll: yes
vignette: |
  %\VignetteIndexEntry{Vignette Title} %\VignetteEngine{knitr::rmarkdown} %\VignetteEncoding{UTF-8}
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(#echo = TRUE,
  collapse = TRUE,
  comment = "#>")
```

## Introduction
This vignette outlines a workflow of parsing and plotting structural variants from Variant Call Format (VCF) using the `StructuralVariantAnnotation` package. `StructuralVariantAnnotation` contains useful helper functions for reading and interpreting structural variants calls. The packages contains functions for parsing VCFs from a number of popular caller as well as functions for dealing with breakpoints involving two separate genomic loci encoded as `GRanges` objects. 

## Installation

The *StructuralVariationAnnotation* package can be loaded from *Bioconductor* as follows:

```{r installation, eval=FALSE}
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
BiocManager::install("StructuralVariantAnnotation")
```

## Breakpoint notation revisited
The [VCF standard](https://samtools.github.io/hts-specs/VCFv4.3.pdf) describes two types of SV notations. One is by SV types, i.e. insertions, deletions, inversions, translocations, etc. The other is by breakend notations, often labelled with `SVTYPE=BND`. To describe a SV with breakend notations, each SV has two positions, each captured by one breakend (except for inversions, which has 4 separate records). Each breakend includes a genomic locus, as well as a half interval extending out to the partner breakend. In VCF BND notations, the `ALT` field encodes directional information of the partner breakend.

* 1	200	.	N	N[5:500[	partner breakend immediately after chr1:200, starting from chr5:500 and extending rightwards
* 1	200	.	N	]5:500]N	partner breakend immediately before chr1:200, extending from the left and ending at chr5:500
* 1	200	.	N	[5:500[N	partner breakend immediately before chr1:200, starting from chr5:500 and extending rightwards
* 1	200	.	N	N]5:500]	partner breakend immediately after chr1:200, extending from the left and ending at chr5:500

## Workflow
### Data preparation and filtering
VCF data is parsed into a `VCF` object using `readVCF` function from Bioconductor package `VariantAnnotation`. Details of `VCF` objects can be found by `browseVignettes("VariantAnnotation")`.
```{r input, warning=FALSE, message=FALSE}
library(VariantAnnotation)
vcf.file <- system.file("extdata", "gridss.vcf", package = "StructuralVariantAnnotation")
vcf <- VariantAnnotation::readVcf(vcf.file, "hg19")
vcf
```

Simple filters could be applied to a `VCF` object to remove unwanted calls.
```{r vcf.filter, warning=FALSE,message=FALSE}
# filter out low quality calls
hq_vcf <- vcf[rowRanges(vcf)$FILTER %in% c(".", "PASS"),]
# somatic calls have no support in the normal
somatic_vcf <- vcf[geno(vcf)$QUAL[,"normal.bam"] == 0,]
# somatic loss of heterozygosity has no support in the tumour
loh_vcf <- vcf[geno(vcf)$QUAL[,"tumour.bam"] == 0,]
```

### Converting SV calls to GRanges
The package employs `GRanges` objects for storage of breakends. Function `breakpointRanges()` converts SVs in a VCF to GRanges with one entry per breakend. A breakend on the '+' strand indicates a break immediately after the given position, and on the '-' strand indicates a break immediately before the given position. Unpaired variants are removed at this stage.

```{r breakpointRanges}
#converting VCF object 'vcf' to GRanges object 'gr'
suppressPackageStartupMessages(library(StructuralVariantAnnotation))
gr <- breakpointRanges(vcf)
gr
```
Some VCF callers support single breakends (see [VCF standard 5.9.2]), 
```{r breakendRanges}
all.gr <- breakendRanges(vcf)
all.gr
```


### Exploring breakpoints

`findBreakpointOverlaps()` and `countBreakpointOverlaps()` are functions for finding and counting overlaps between breakpoint objects. All breakends must have their partner breakend included in the GRanges. A valid overlap requires that breakends on boths sides overlap.

<!-- **EXAMPLE HERE FOR GENE OVERLAP** -->
<!-- # ```{r, warning=FALSE, message=FALSE} -->
<!-- # library(dplyr) -->
<!-- # library(plyranges) -->
<!-- # region.gr <- data.frame(seqnames=c('chr12','chr12'),start=c(84350,4886681),end=c(84350,4886681),strand=c('-','+'), vcfID=c('gridss100o','gridss100h'), partner=c('gridss100h','gridss100o')) %>% as_granges() -->
<!-- # region.gr <- setNames(region.gr, c('gridss100o','gridss100h')) -->
<!-- # region.gr -->
<!-- # ``` -->

To demonstrate `findBreakpointOverlaps()` function, we construct a toy `GRanges` object `region.gr` using two partnered breakpoints from `gr`. The output matrix reports the index of overlapping breakpoints (`queryHits` and `subjectHits`), and overlapping distances (`sizeerror`, `localbperror` and `remotebperror`). 
```{r}
#load `plyranges` for GRanges modification
suppressPackageStartupMessages(library(plyranges))
#toy GRanges `region.gr`
region.gr <- gr[2:3,]  %>% mutate(end=end+5) %>% mutate(start=start+5)
# event sizes must be within sizemargin
findBreakpointOverlaps(gr, region.gr)
```
`countBreakpointOverlaps` reports count of overlaps for each breakpoint.
```{r}
#suppressPackageStartupMessages(library(dplyr))
countBreakpointOverlaps(gr, region.gr)
```

`partner()` returns a `GRanges` object, in which each entry is the partner breakend of those in `gr`.
```{r}
partner(gr)
```


### Converting between BEDPE files and GRanges

The package supports converting GRanges objects to BEDPE files. The BEDPE format is defined by [`bedtools`](https://bedtools.readthedocs.io/en/latest/content/general-usage.html).

```{r}
bedpe <- breakpointgr2bedpe(gr)
bedpe
write.table(bedpe, file="gridss.bedpe", quote=FALSE, sep='\t', row.names=FALSE, col.names=FALSE)
```

BEDPE files can be imported as GRanges objects via `bedpe2breakpointgr()`.
```{r}
bedpe.gr <- bedpe2breakpointgr('gridss.bedpe')
bedpe.gr
```




## Visualising breakpoint pairs via circos plots

One way of visualising paired breakpoints is by circos plots. Here we use package [`circlize`](https://doi.org/10.1093/bioinformatics/btu393) to demonstrate breakpoint visualisation. The `bedpe2circos` function takes BEDPE-formatted dataframes (see `breakpointgr2bedpe()`) and plotting parameters for `circos.initializeWithIdeogram()` and `circos.genomicLink()` functions from `circlize`.

To generate a simple circos plot of paired breakpoints:
```{r}
bedpe2circos(bedpe)
```

If you'd like to add extra circular plots on the circos plot, you can do:
```{r}
suppressPackageStartupMessages(library(circlize))
bedpe2circos(bedpe)
circos.genomicLink(bedpe[,4:6], bedpe[,4:6])
circos.clear()
```
Alternatively, you can save the code chunk as an object and call it later:
```{r}
suppressPackageStartupMessages(library(pryr))
circos.plot %<a-% bedpe2circos(bedpe, chromosome.index= paste0('chr',c(1,12)))
#some other code
circos.plot
circos.genomicLink(bedpe[,4:6], bedpe[,4:6])
circos.clear()
```


## SessionInfo
```{r}
sessionInfo()
```
