---
title: "StructuralVariantAnnotation Quick Overview"
author: "Ruining Dong"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: yes
    toc_float:
      collapsed: yes
      smooth_scroll: yes
vignette: >
  %\VignetteIndexEntry{Structural Variant Annotation Package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(#echo = TRUE,
  collapse = TRUE,
  comment = "#>")
```

## Introduction
This vignette outlines a workflow of parsing and plotting structural variants from Variant Call Format (VCF) using the `StructuralVariantAnnotation` package. `StructuralVariantAnnotation` contains useful helper functions for reading and interpreting structural variants calls. The packages contains functions for parsing VCFs from a number of popular callers as well as functions for dealing with breakpoints involving two separate genomic loci encoded as `GRanges` objects. 

## Installation

The *StructuralVariationAnnotation* package can be installed from *Bioconductor* as follows:

```{r installation, eval=FALSE}
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
BiocManager::install("StructuralVariantAnnotation")
```

## Breakpoint notation
The [VCF standard](https://samtools.github.io/hts-specs/VCFv4.3.pdf) describes two types of SV notations. One is by SV types, i.e. insertions, deletions, inversions, translocations, etc. The other is by breakend notations, often labelled with `SVTYPE=BND`. To describe a SV with breakend notations, each SV has two positions, each captured by one breakend (except for inversions, which has 4 separate records). Each breakend includes a genomic locus, as well as a half interval extending out to the partner breakend. In VCF BND notations, the `ALT` field encodes directional information of the partner breakend.

* 1	200	.	N	N[5:500[	partner breakend immediately after chr1:200, starting from chr5:500 and extending rightwards
* 1	200	.	N	]5:500]N	partner breakend immediately before chr1:200, extending from the left and ending at chr5:500
* 1	200	.	N	[5:500[N	partner breakend immediately before chr1:200, starting from chr5:500 and extending rightwards
* 1	200	.	N	N]5:500]	partner breakend immediately after chr1:200, extending from the left and ending at chr5:500

## Workflow
### Data preparation and filtering
VCF data is parsed into a `VCF` object using `readVCF` function from 
Bioconductor package `VariantAnnotation`. Simple filters could be applied to a 
`VCF` object to remove unwanted calls. More information about `VCF` objects can be found by
consulting the vignetts in the VariantAnnotation package with `browseVignettes("VariantAnnotation")`.
```{r input, warning=FALSE, message=FALSE}
library(VariantAnnotation)
vcf.file <- system.file("extdata", "gridss.vcf", package = "StructuralVariantAnnotation")
vcf <- VariantAnnotation::readVcf(vcf.file, "hg19")
vcf
```

### Converting SV calls to GRanges
The package employs `GRanges` objects for storage of breakends. Function 
`breakpointRanges()` converts SVs in a VCF to GRanges with one entry per 
breakend. A breakend on the '+' strand indicates a break immediately after the 
given position, to the left of which is the DNA segment involved in the 
breakpoint. The '-' strand indicates a break immediately before the given 
position, rightwards of which is the DNA segment involved in the breakpoint. 
Unpaired variants are removed at this stage. Leftward of the '+' strand is the 
breakpoint involved.

```{r breakpointRanges}
#converting VCF object 'vcf' to GRanges object 'gr'
suppressPackageStartupMessages(library(StructuralVariantAnnotation))
gr <- breakpointRanges(vcf)
gr
```


### Breakpoint Overlaps

`findBreakpointOverlaps()` and `countBreakpointOverlaps()` are functions for finding and counting overlaps between breakpoint objects. All breakends must have their partner breakend included in the GRanges. A valid overlap requires that breakends on boths sides overlap.

To demonstrate `findBreakpointOverlaps()` function, we construct a toy `GRanges` object `region.gr` using two partnered breakpoints from `gr`. The output `Hits` object reports the index of overlapping breakpoints (`queryHits` and `subjectHits`). 
```{r}
#toy GRanges `region.gr`
region.gr <- shift(gr[2:3,],5) 
# event sizes must be within sizemargin
findBreakpointOverlaps(query = gr, subject = region.gr, maxgap = 5)
```
`countBreakpointOverlaps` reports count of overlaps for each breakpoint.
```{r}
countBreakpointOverlaps(gr, region.gr, maxgap = 5)
```

`partner()` returns a `GRanges` object, in which each entry is the partner breakend of those in `gr`.
```{r}
partner(gr)
```


### Converting between BEDPE files and GRanges

The package supports converting GRanges objects to BEDPE files. The BEDPE format is defined by [`bedtools`](https://bedtools.readthedocs.io/en/latest/content/general-usage.html).

```{r}
bedpe <- breakpointgr2bedpe(gr)
bedpe
#save bedpe as a tabulated text file
write.table(bedpe, file="gridss.bedpe", quote=FALSE, sep='\t', row.names=FALSE, col.names=FALSE)
```

BEDPE files can be imported as GRanges objects via `bedpe2breakpointgr()`.
```{r}
bedpe.file <- 'gridss.bedpe'
bedpe.gr <- bedpe2breakpointgr(bedpe.file)
bedpe.gr
```




## Visualising breakpoint pairs via circos plots

One way of visualising paired breakpoints is by circos plots. Here we use package 
[`circlize`](https://doi.org/10.1093/bioinformatics/btu393) to demonstrate 
breakpoint visualisation. The `bedpe2circos` function takes BEDPE-formatted 
dataframes (see `breakpointgr2bedpe()`) and plotting parameters for 
`circos.initializeWithIdeogram()` and `circos.genomicLink()` functions 
from `circlize`.

To generate a simple circos plot of paired breakpoints:
```{r}
suppressPackageStartupMessages(library(circlize))
circos.initializeWithIdeogram()
circos.genomicLink(bedpe[,1:3], bedpe[,4:6])
circos.clear()
```

Alternatively, plotting package such as `ggbio` provides flexible tracks 
function which binds
with `ggplot2()` objects. It takes `GRanges` objects as input and support circos
plots.
To plot structural variant breakpoints in a circos plot using `ggbio`, we need
to first prepare the breakpoint GRanges. The function requires a sepecial column,
indicating the end of the link using GRanges format, which we can add to `gr` using
[`plyranges`](https://bioconductor.org/packages/release/bioc/html/plyranges.html).
```{r add to.gr}
suppressPackageStartupMessages(library(ggbio))
gr.circos <- gr
seqlevelsStyle(gr.circos) <- 'Ensembl' #remove 'chr' prefix
seqlevels(gr.circos)<-seqlevels(biovizBase::hg19sub)
mcols(gr.circos)$to.gr <- granges(partner(gr.circos))
```
We can then plot the breakpoints against reference genomes.
```{r ggbio}
p <- ggbio() +
	circle(gr.circos, geom="link", linked.to="to.gr") +
	circle(biovizBase::hg19sub, geom='ideo', fill='gray70') +
	circle(biovizBase::hg19sub, geom='scale', size=2) +
	circle(biovizBase::hg19sub, geom='text', aes(label=seqnames), vjust=0, size=3)
p
```

## SessionInfo
```{r}
sessionInfo()
```
