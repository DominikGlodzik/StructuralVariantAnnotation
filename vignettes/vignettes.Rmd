---
title: "StructuralVariantAnnotation Quick Overview"
author: "Ruining Dong"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: yes
    toc_float:
      collapsed: yes
      smooth_scroll: yes
vignette: >
  %\VignetteIndexEntry{Structural Variant Annotation Package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(#echo = TRUE,
  collapse = TRUE,
  comment = "#>")
```

## Introduction
This vignette outlines a workflow of parsing and plotting structural variants from Variant Call Format (VCF) using the `StructuralVariantAnnotation` package. `StructuralVariantAnnotation` contains useful helper functions for reading and interpreting structural variants calls. The packages contains functions for parsing VCFs from a number of popular callers as well as functions for dealing with breakpoints involving two separate genomic loci encoded as `GRanges` objects. 

## Installation

The *StructuralVariationAnnotation* package can be installed from *Bioconductor* as follows:

```{r installation, eval=FALSE}
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
BiocManager::install("StructuralVariantAnnotation")
```

## Breakpoint notation
The [VCF standard](https://samtools.github.io/hts-specs/VCFv4.3.pdf) describes two types of SV notations. One is by SV types, i.e. insertions, deletions, inversions, translocations, etc. The other is by breakend notations, often labelled with `SVTYPE=BND`. To describe a SV with breakend notations, each SV has two positions, each captured by one breakend (except for inversions, which has 4 separate records). Each breakend includes a genomic locus, as well as a half interval extending out to the partner breakend. In VCF BND notations, the `ALT` field encodes directional information of the partner breakend.

* 1	200	.	N	N[5:500[	partner breakend immediately after chr1:200, starting from chr5:500 and extending rightwards
* 1	200	.	N	]5:500]N	partner breakend immediately before chr1:200, extending from the left and ending at chr5:500
* 1	200	.	N	[5:500[N	partner breakend immediately before chr1:200, starting from chr5:500 and extending rightwards
* 1	200	.	N	N]5:500]	partner breakend immediately after chr1:200, extending from the left and ending at chr5:500

## Workflow
### Data preparation and filtering
VCF data is parsed into a `VCF` object using `readVCF` function from 
Bioconductor package `VariantAnnotation`. Simple filters could be applied to a 
`VCF` object to remove unwanted calls. More information about `VCF` objects can be found by
consulting the vignetts in the VariantAnnotation package with `browseVignettes("VariantAnnotation")`.
```{r input, warning=FALSE, message=FALSE}
library(VariantAnnotation)
vcf.file <- system.file("extdata", "gridss.vcf", package = "StructuralVariantAnnotation")
vcf <- VariantAnnotation::readVcf(vcf.file, "hg19")
vcf
```

### Converting SV calls to GRanges
The package employs `GRanges` objects for storage of breakends. Function 
`breakpointRanges()` converts SVs in a VCF to GRanges with one entry per 
breakend. A breakend on the '+' strand indicates a break immediately after the 
given position, to the left of which is the DNA segment involved in the 
breakpoint. The '-' strand indicates a break immediately before the given 
position, rightwards of which is the DNA segment involved in the breakpoint. 
Unpaired variants are removed at this stage. Leftward of the '+' strand is the 
breakpoint involved.

```{r breakpointRanges}
#converting VCF object 'vcf' to GRanges object 'gr'
suppressPackageStartupMessages(library(StructuralVariantAnnotation))
gr <- breakpointRanges(vcf)
gr
```


### Breakpoint Overlaps

`findBreakpointOverlaps()` and `countBreakpointOverlaps()` are functions for finding and counting overlaps between breakpoint objects. All breakends must have their partner breakend included in the GRanges. A valid overlap requires that breakends on boths sides overlap.

To demonstrate `countBreakpointOverlaps()` function, we use a small subset of data from our structural variant caller benchmarking paper to construct precision recall curves for a pair of callers. 
```{r}
require(VariantAnnotation)
truth_vcf = readVcf("inst/extdata/na12878_chr22_Sudmunt2015.vcf")
truth_svgr = breakpointRanges(truth_vcf)
truth_svgr = truth_svgr[seqnames(truth_svgr) == "chr22"]
crest_vcf = readVcf("inst/extdata/na12878_chr22_crest.vcf")
# Some SV callers don't report QUAL so we need to use a proxy
VariantAnnotation::fixed(crest_vcf)$QUAL = info(crest_vcf)$left_softclipped_read_count + info(crest_vcf)$left_softclipped_read_count
crest_svgr = breakpointRanges(crest_vcf)
crest_svgr$caller = "crest"
hydra_vcf = readVcf("inst/extdata/na12878_chr22_hydra.vcf")
hydra_svgr = breakpointRanges(hydra_vcf)
hydra_svgr$caller = "hydra"
svgr = c(crest_svgr, hydra_svgr)
svgr$truth_matches = countBreakpointOverlaps(svgr, truth_svgr,
  # read pair based callers make imprecise calls.
  # A margin around the call position is required when matching with the truth set
  maxgap=100,
  # Since we added a maxgap, we also need to restrict the mismatch between then
  # size of the events. We don't want to match a 100bp deletion with a 
  # 5bp dupliaction. This will happen if we have a 100bp margin but don't also
  # require an approximate size match as well
  sizemargin=0.25,
  # We also don't want to match a 20bp deletion with a 20bp deletion 80bp away
  # by restricting the margin based on the size of the event, we can make sure
  # that simple events actually do overlap
  restrictMarginToSizeMultiple=0.5,
  # HYDRA makes duplicate calls and will sometimes report a variant multiple
  # times with slightly different bounds. countOnlyBest prevents these being
  # double-counted as multiple true positives.
  countOnlyBest=TRUE)
```
Once we know which calls match the truth set, it is relatively straight-forward to generate Precision-Recall and ROC curves for each caller.
```{r}
library(tidyverse)
ggplot(as.data.frame(svgr) %>%
  dplyr::select(QUAL, caller, truth_matches) %>%
  dplyr::group_by(caller, QUAL) %>%
  dplyr::summarise(
    calls=n(),
    tp=sum(truth_matches > 0)) %>%
  dplyr::group_by(caller) %>%
  dplyr::arrange(dplyr::desc(QUAL)) %>%
  dplyr::mutate(
    cum_tp=cumsum(tp),
    cum_n=cumsum(calls),
    cum_fp=cum_n - cum_tp,
    Precision=cum_tp / cum_n,
    Recall=cum_tp/length(truth_svgr))) +
  aes(x=Recall, y=Precision, colour=caller) +
  geom_point() +
  geom_line() +
  labs(title="NA12878 chr22 CREST and HYDRA\nSudmunt 2015 truth set")
```

`partner()` returns a `GRanges` object, in which each entry is the partner breakend of those in `gr`.
```{r}
partner(gr)
```


### Converting between BEDPE files and GRanges

The package supports converting GRanges objects to BEDPE files. The BEDPE format is defined by [`bedtools`](https://bedtools.readthedocs.io/en/latest/content/general-usage.html).

```{r}
bedpe <- breakpointgr2bedpe(gr)
bedpe
#save bedpe as a tabulated text file
write.table(bedpe, file="gridss.bedpe", quote=FALSE, sep='\t', row.names=FALSE, col.names=FALSE)
```

BEDPE files can be imported as GRanges objects via `bedpe2breakpointgr()`.
```{r}
bedpe.file <- 'gridss.bedpe'
bedpe.gr <- bedpe2breakpointgr(bedpe.file)
bedpe.gr
```




## Visualising breakpoint pairs via circos plots

One way of visualising paired breakpoints is by circos plots. Here we use package 
[`circlize`](https://doi.org/10.1093/bioinformatics/btu393) to demonstrate 
breakpoint visualisation. The `bedpe2circos` function takes BEDPE-formatted 
dataframes (see `breakpointgr2bedpe()`) and plotting parameters for 
`circos.initializeWithIdeogram()` and `circos.genomicLink()` functions 
from `circlize`.

To generate a simple circos plot of paired breakpoints:
```{r}
suppressPackageStartupMessages(library(circlize))
circos.initializeWithIdeogram()
circos.genomicLink(bedpe[,1:3], bedpe[,4:6])
circos.clear()
```

Alternatively, plotting package such as `ggbio` provides flexible tracks 
function which binds
with `ggplot2()` objects. It takes `GRanges` objects as input and support circos
plots.
To plot structural variant breakpoints in a circos plot using `ggbio`, we need
to first prepare the breakpoint GRanges. The function requires a sepecial column,
indicating the end of the link using GRanges format, which we can add to `gr` using
[`plyranges`](https://bioconductor.org/packages/release/bioc/html/plyranges.html).
```{r add to.gr}
suppressPackageStartupMessages(library(ggbio))
gr.circos <- gr
seqlevelsStyle(gr.circos) <- 'Ensembl' #remove 'chr' prefix
seqlevels(gr.circos)<-seqlevels(biovizBase::hg19sub)
mcols(gr.circos)$to.gr <- granges(partner(gr.circos))
```
We can then plot the breakpoints against reference genomes.
```{r ggbio}
p <- ggbio() +
	circle(gr.circos, geom="link", linked.to="to.gr") +
	circle(biovizBase::hg19sub, geom='ideo', fill='gray70') +
	circle(biovizBase::hg19sub, geom='scale', size=2) +
	circle(biovizBase::hg19sub, geom='text', aes(label=seqnames), vjust=0, size=3)
p
```

## SessionInfo
```{r}
sessionInfo()
```
