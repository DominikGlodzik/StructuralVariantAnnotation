---
title: "StructuralVariantAnnotation Quick Overview"
author: "Ruining Dong"
# date: "17/02/2019"
# output:
#   html_document:
#     df_print: paged
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(#echo = TRUE,
  collapse = TRUE,
  comment = "#>")
```

## Introduction
This vignette outlines a workflow of parsing and plotting structural variants from Variant Call Format (VCF) using the `StructuralVariantAnnotation` package. `StructuralVariantAnnotation` contains useful helper functions for reading and interpreting structural variants calls. The packages contains functions for parsing VCFs from a number of popular caller as well as functions for dealing with breakpoints involving two separate genomic loci encoded as `GRanges` objects. 

## Installation

The *StructuralVariationAnnotation* package can be loaded from *Bioconductor* as follows:

```{r, eval=FALSE}
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
BiocManager::install("StructuralVariantAnnotation")
```

## Workflow
### Data preparation and filtering
VCF data is parsed into a `VCF` object using `readVCF` function from Bioconductor package `VariantAnnotation`. Details of `VCF` objects can be found by `browseVignettes("VariantAnnotation")`.
```{r, warning=FALSE, message=FALSE}
library(VariantAnnotation)
vcf.file <- system.file("extdata", "gridss.vcf", package = "StructuralVariantAnnotation")
vcf <- VariantAnnotation::readVcf(vcf.file, "hg19")
vcf
```

Simple filters could be applied to a `VCF` object to remove unwanted calls.
```{r, warning=FALSE,message=FALSE}
# filter out low quality calls
hq_vcf <- vcf[rowRanges(vcf)$FILTER %in% c(".", "PASS"),]
# somatic calls have no support in the normal
somatic_vcf <- vcf[geno(vcf)$QUAL[,"normal.bam"] == 0,]
# somatic loss of heterozygosity has no support in the tumour
loh_vcf <- vcf[geno(vcf)$QUAL[,"tumour.bam"] == 0,]
```

### Converting SV calls to GRanges
The package employs `GRanges` objects for storage of breakends. Function `breakpointRanges()` converts SVs in a VCF to GRanges with one entry per breakend. A breakend on the '+' strand indicates a break immediately after the given position, and on the '-' strand indicates a break immediately before the given position. Unpaired variants are removed at this stage.

```{r}
#converting VCF object 'vcf' to GRanges object 'gr'
suppressPackageStartupMessages(library(StructuralVariantAnnotation))
gr <- breakpointRanges(vcf)
gr
```


### Exploring breakpoints

`findBreakpointOverlaps()` and `countBreakpointOverlaps()` are functions for finding and counting overlaps between GRanges objects, equivalent of `findOverlaps()` and `countOverlaps()`. All breakends must have their partner breakend included in the GRanges. A valid overlap requires that breakends on boths sides overlap.

<!-- **EXAMPLE HERE FOR GENE OVERLAP** -->
<!-- # ```{r, warning=FALSE, message=FALSE} -->
<!-- # library(dplyr) -->
<!-- # library(plyranges) -->
<!-- # region.gr <- data.frame(seqnames=c('chr12','chr12'),start=c(84350,4886681),end=c(84350,4886681),strand=c('-','+'), vcfID=c('gridss100o','gridss100h'), partner=c('gridss100h','gridss100o')) %>% as_granges() -->
<!-- # region.gr <- setNames(region.gr, c('gridss100o','gridss100h')) -->
<!-- # region.gr -->
<!-- # ``` -->

To demonstrate `findBreakpointOverlaps()` function, we construct a toy `GRanges` object `region.gr` using two partnered breakpoints from `gr`. The output matrix reports the index of overlapping breakpoints (`queryHits` and `subjectHits`), and overlapping distances (`sizeerror`, `localbperror` and `remotebperror`). 
```{r}
# event sizes must be within sizemargin
region.gr <- gr[2:3,]
findBreakpointOverlaps(gr, region.gr)
```
`countBreakpointOverlaps` reports count of overlaps for each breakpoint.
```{r}
suppressPackageStartupMessages(library(dplyr))
countBreakpointOverlaps(gr, region.gr)
```

`partner()` returns partner breakend for each breakend.
```{r}
partner(gr)
```


### Converting between BEDPE files and GRanges

The package supports converting GRanges objects to BEDPE files. The BEDPE format is defined by [`bedtools`](https://bedtools.readthedocs.io/en/latest/content/general-usage.html).

```{r}
#suppressPackageStartupMessages(library(stringr))
bedpe <- breakpointgr2bedpe(gr)
bedpe
write.table(bedpe, file="gridss.bedpe", quote=FALSE, sep='\t', row.names=FALSE, col.names=FALSE)
```

BEDPE files can be imported to GRanges objects in R via `bedpe2breakpointgr`.
```{r}
bedpe.gr <- bedpe2breakpointgr('gridss.bedpe')
bedpe.gr
```




### Visualising breakpoint pairs via circos plots

One way of visualising paired breakpoints is by circos plots. Here we use package [`circlize`](https://doi.org/10.1093/bioinformatics/btu393) to demonstrate breakpoint visualisation. The `bedpe2circos` function takes BEDPE-formatted dataframes (see `breakpointgr2bedpe()`) and plotting parameters for `circos.initializeWithIdeogram()` and `circos.genomicLink()` functions from `circlize`.

To generate a simple circos plot of paired breakpoints:
```{r}
bedpe2circos(bedpe)
```

If you'd like to add extra circular plots on the circos plot, you can do:
```{r}
suppressPackageStartupMessages(library(circlize))
bedpe2circos(bedpe)
circos.genomicLink(bedpe[,4:6], bedpe[,4:6])
circos.clear()
```
Alternatively, you can save the code chunk as an object and call it later:
```{r}
suppressPackageStartupMessages(library(pryr))
circos.plot %<a-% bedpe2circos(bedpe, chromosome.index= paste0('chr',c(1,12)))
#some other code
circos.plot
circos.genomicLink(bedpe[,4:6], bedpe[,4:6])
circos.clear()
```


## SessionInfo
```{r}
sessionInfo()
```
## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.


bedpe2breakpointgr , breakendRanges, breakpointRanges, countBreakpointOverlaps, findBreakpointOverlaps, partner, isStructural, isSymbolic, pairs2breakpointgr
