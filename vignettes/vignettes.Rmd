---
title: "StructuralVariantAnnotation Quick Overview"
author: "Ruining Dong"
date: "17/02/2019"
output:
  html_document:
    df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction
This vignette outlines a workflow of annoating and filtering structural variant from Variant Call Format (VCF) **REF** using the *StructuralVariantAnnotation* package. *StructuralVariantAnnotation* contains useful helper functions for reading and interpreting structural variants calls. The packages contains functions for parsing VCFs from a number of popular caller as well as functions for dealing with breakpoints involving two separate genomic loci encoded as GRanges objects. 

## Installation

The *StructuralVariationAnnotation* package can be loaded from *Bioconductor* as follows:

```{r, eval=FALSE}
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
BiocManager::install("StructuralVariantAnnotation")
```

## Workflow
### Data import and filtering
VCF data is parsed into a `VCF` object using `readVCF` function from Bioconductor package `VariantAnnotation`. Details of `VCF` objects can be found by `browseVignettes("VariantAnnotation")`.
```{r, warning=FALSE, message=FALSE}
library(VariantAnnotation)
library(StructuralVariantAnnotation)
vcf.file <- system.file("extdata", "gridss.vcf", package = "StructuralVariantAnnotation")
vcf <- readVcf(vcf.file, "hg19")
vcf
```

Simple filters could be applied to a `VCF` object to remove unwanted calls.
```{r, warning=FALSE,message=FALSE}
# filter out low quality calls
vcf <- vcf[rowRanges(vcf)$FILTER %in% c(".", "PASS"),]
# somatic calls have no support in the normal
somatic_vcf <- vcf[geno(vcf)$QUAL[,"normal.bam"] == 0,]
# somatic loss of heterozygosity has no support in the tumour
loh_vcf <- vcf[geno(vcf)$QUAL[,"tumour.bam"] == 0,]
```

### Converting SV calls
The package employs `GRanges` object for storage of breakends. Function `breakpointRanges()` converts SVs in a VCF to GRanges with one entry per breakend. A breakend on the '+' strand indicates a break immediately after the given position, and on the '-' strand indicates a break immediately before the given position. Unpaired variants are removed at this stage.

```{r}
#converting VCF object 'vcf' to GRanges object 'gr'
gr <- breakpointRanges(vcf)
gr
```

### Interpreting breakpoints

`findBreakpointOverlaps()` and `countBreakpointOverlaps()` are functions for finding and counting overlaps between GRanges objects, equivalent of `findOverlaps()` and `countOverlaps()`.

**EXAMPLE HERE FOR GENE OVERLAP**

### Converting between BEDPE files and GRanges
```{r}
library(stringr)
bedpe <- data.frame(
    chrom1=seqnames(gr),
    start1=start(gr) - 1,
    end1=end(gr),
    chrom1=seqnames(partner(gr)),
    start2=start(partner(gr)) - 1,
    end2=end(partner(gr)),
    name=names(gr),
    score=gr$QUAL,
    strand1=strand(gr),
    strand2=strand(partner(gr))
    )
bedpe <- bedpe[str_detect(bedpe$name, "gridss.+o"),]
#bedpe <- bedpe[str_detect(bedpe$name, "gridss.+o"),]
#write.table(bedpe, "gridss.bedpe", quote=FALSE, sep='\t', row.names=FALSE, col.names=FALSE)
```


## SessionInfo
```{r}
sessionInfo()
```
## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.


bedpe2breakpointgr , breakendRanges, breakpointRanges, countBreakpointOverlaps, findBreakpointOverlaps, partner, isStructural, isSymbolic, pairs2breakpointgr
